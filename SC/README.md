<br/>

# 🌈 객체 지향 프로그래밍 이란?

<br/>

## ✅ 객체 지향 기법의 구성 요소

<br/>

### 1. 객체(Object) : 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화) 하나의 소프트웨어 모듈

- 데이터(Data) : 객체가 가지고 있는 속성
- 함수(Method) : 객체가 수행하는 기능. 객체가 갖는 데이터를 처리하는 알고리즘

### 예시 )

- 객체 = 심장
- 데이터 = 혈액
- 함수 = 대동맥, 정맥으로 피를 보내는 기능

<br/>

### 2. 클래스(Class) : 공통된 속성과 연산(행위)를 갖는 객체의 집합. 각각의 개체들이 갖는 속성과 연산을 정의하고 있는 틀

- 인스턴스(Instance) : 클래스에 속학 각각의 개체.
- 인스턴스화(Instantiaion) : 클래스로부터 새로운 객체를 생성하는 것

### 예시 )

- 클래스 : 호흡기관
- 인스턴스 : 폐, 기도
- 인스턴스화 : 호흡기관에 추가적으로 넣는 과정

<br/>

### 3. 메시지(Message) : 객체들 간에 상호작용을 하는데 사용 되는 수단. 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구 사항

### 예시 )

- 메세지 : 뉴런( 신호 전달 )

<br/>
<br/>
<br/>

# 🌈 [자료 구조] Stack & Queue & Linked List

자료 구조는 Coding과는 별로 상관없어 보일 수 있겠지만 프로그래밍에 있어서 매우 중요한 부분이다.

- 내가 어떠한 프로그램을 구현 할 때, 혹은 어떤 알고리즘 문제를 해결 하거나 새로운 Logic을 만들 때
- 데이터를 어떤 구조로 저장 하느냐에 따라서 프로그램의 효율성이나 성능 면에서 차이가 날 수 있다.

<br/>

## ✅ 1. Stack

- Stack은 자료를 한 줄로 블록을 쌓듯이 추가하는 형태의 자료 구조 입니다.
- Stack 맨 위에 자료를 `추가` 하는 것을 `Push` 라고 하고
- 반대로 맨 위의 자료를 하나씩 `제거`하는 것(`꺼내는 것`)을 `Pop` 이라고 합니다.

- 위 그림처럼 Stack은 어느 한 곳에 Block 처럼 자료가 쌓기 때문에
- 자료를 제거 할 때 가장 마지막에 들어간 자료가 가장 먼저 제거 됩니다. (LIFO : Last-in First-Out)

<br/>
<br/>

## ✅ Big O(시간 복잡도)

- 우리가 Stack을 통해 자료를 삽입, 삭제, 검색의 과정을 거친다고 생각해 볼 때
- 컴퓨터에서는 이 과정이 얼마나 걸리는지 정확히 알 수 없습니다.
- 그래서 우리는 어떤 연산을 하는데 몇 차례의 과정이 진행되는지 에 따라
- 소요 시간과 효율성을 측정 할 수 있습니다.
- 이 때 연산 과정을 간편하게 표기해서 쓸 수 있는 수학적인 표기법을 Big O라고 부릅니다

- O(1)의 표현에서 1은 상수 시간을 말합니다.
- 예를 들어 Stack에 자료를 추가 할 경우 항상 Stack의 맨 위에 자료를 Push 하기만 하면 됩니다.
- 즉 자료의 개수가 몇 개 인지 혹은 다른 어떠한 사항도 고려할 필요가 없습니다.
- 그저 자료를 기존의 자료 맨 위에 올리기만 하면 된다는 뜻입니다.
- 그러므로 한번의 Operation으로 자료의 삽입이 수행 되기 때문에 O(1)이라고 표현 할 수 있습니다.
- 단 O(1)은 한 번만 연산이 된다는 의미가 아닙니다.
- 어떤 작업을 수행할 때 마다 항상 동일한 작업만을 수행한다면 작업들을 O(1)로 표현 할 수 있습니다.
- 마찬가지로 자료를 삭제 할 때도 자료의 개수와 상관없이 맨 위에 있는 자료를 Pop하면 되기 때문에
- 자료의 삭제도 O(1)로 표기 할 수 있습니다.

- 그렇다면 자료의 검색은 어떨 까요?
- 만약 Stack에 5개의 블록이 쌓여 있다면 우리는 맨 위의 Block에서 부터 맨 마지막 Block까지 순차적으로 검색하여 자료를 찾아야 합니다.
- 운이 좋게 첫 번째 Block이 우리가 찾는 Block이 있다면 한 번의 검색으로 답을 찾을 수 있겠지만
- 만약에 맨 마지막 Block이 우리가 찾는 Block이라면 우리는 맨 마지막 Block이 나올 때 까지 5번의 검색 과정을 거쳐야 합니다.
- 그러므로 Stack의 검색 횟수는 가장 최악의 경우인 O(n)으로 표기 할 수 있습니다.

<br/>

### ⭐️Stack 예시

- Call Stack : JS는 모든 함수 호출을 Stack 자료 구조로 이루어져 있습니다. 특히 재귀 함수를 사용 할 때 가장 중요하게 다뤄진다.
- Undo / Redo Mechanism : 포토샵의 기능 중 Ctrl+Alt+Z를 눌러 방금 전의 작업들을 뒤에서 부터 순차적으로 취소 할 수 있다. 우리가 실행한 작업들이 순차적으로 Stack 자료 구조로 저장되고, 취소 단축키를 누를 때 마다 맨 위의 자료들이 삭제 되기 때문이다.

<br/>
<br/>
<br/>

## ✅ 3. Linked List(연결 리스트)

- Linked List는 여러 노드들이 연결되어 있는 구조입니다.
- 연결 리스트의 맨 앞을 Head, 맨 마지막을 Tail이라고 합니다.
- 노드들은 다음에 올 노드의 정보를 가지고 있다.

- 만약 연결 리스트에 자료를 삽입하려고 한다면 우리는 위 그림과 같이 자료를 추가할 장소로 가서
- 기존의 링크를 끊은 다음 추가할 위치의 이 전 요소의 꼬리와 삽입할 자료의 꼬리를 연결해야 합니다.
- 그리고 추가할 요소의 꼬리와 다음 요소의 꼬리를 연결해 주면 됩니다.
- 이 때에 오직 앞 요소와 다음 요소와 연결시켜주는 Operation만 수행 되므로 시간 복잡도는 O(1)입니다.

- 만약에 연결 리스트에 특정 자료를 삭제하려고 한다면 위의 그림처럼 삭제하고자 하는 요소의 이전 요소의 꼬리를 다음 요소와 연결 시켜 주면 됩니다.
- 마찬 가지로 삭제하고자 하는 요소의 이전 요소와 다음 요소를 연결시켜주는 Operation이 수행 되므로 시간 복잡도는 O(1)입니다.
- 또한 연결 리스트에서 자료를 검색하고 싶다면 맨 앞의 Head에서 부터 시작해야 합니다.
- 왜냐하면 연결 리스트의 각 노드들은 다음 요소들의 정보를 가지고 있기 때문입니다.
- 그러므로 맨 앞의 리스트 에서 부터 그 다음의 노들로 순차적으로 검색해야 합니다.
- 이 때의 시간 복잡도는 O(n)입니다.

<br/>

### ⭐️Stack 예시

- 웹 브라우저에서 여러 사이트들을 실행하고 난 후 History는 연결 리스트와 같은 구조로 저장됩니다.
- 내가 어떤 사이트들에서 다른 사이트로 넘어갈 때, 이전 사이트의 정보를 가지고 넘어가기 때문입니다.
- 따라서 우리가 브라우저에서 이전 버튼, 다음 버튼, 누르면 이전에, 혹은 다음에 열람 했던 사이트들로 이동 할 수 있습니다.
