<br/>

# 🌈 객체 지향 프로그래밍 이란?

<br/>

## ✅ 객체 지향 기법의 구성 요소

<br/>

### 1. 객체(Object) : 데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화) 하나의 소프트웨어 모듈

- 데이터(Data) : 객체가 가지고 있는 속성
- 함수(Method) : 객체가 수행하는 기능. 객체가 갖는 데이터를 처리하는 알고리즘

### 예시 )

- 객체 = 심장
- 데이터 = 혈액
- 함수 = 대동맥, 정맥으로 피를 보내는 기능

<br/>

### 2. 클래스(Class) : 공통된 속성과 연산(행위)를 갖는 객체의 집합. 각각의 개체들이 갖는 속성과 연산을 정의하고 있는 틀

- 인스턴스(Instance) : 클래스에 속학 각각의 개체.
- 인스턴스화(Instantiaion) : 클래스로부터 새로운 객체를 생성하는 것

### 예시 )

- 클래스 : 호흡기관
- 인스턴스 : 폐, 기도
- 인스턴스화 : 호흡기관에 추가적으로 넣는 과정

<br/>

### 3. 메시지(Message) : 객체들 간에 상호작용을 하는데 사용 되는 수단. 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구 사항

### 예시 )

- 메세지 : 뉴런( 신호 전달 )

<br/>
<br/>
<br/>

# 🌈 [자료 구조] Stack & Queue & Linked List

자료 구조는 Coding과는 별로 상관없어 보일 수 있겠지만 프로그래밍에 있어서 매우 중요한 부분이다.

- 내가 어떠한 프로그램을 구현 할 때, 혹은 어떤 알고리즘 문제를 해결 하거나 새로운 Logic을 만들 때
- 데이터를 어떤 구조로 저장 하느냐에 따라서 프로그램의 효율성이나 성능 면에서 차이가 날 수 있다.

<br/>

## ✅ 1. Stack

- Stack은 자료를 한 줄로 블록을 쌓듯이 추가하는 형태의 자료 구조 입니다.
- Stack 맨 위에 자료를 `추가` 하는 것을 `Push` 라고 하고
- 반대로 맨 위의 자료를 하나씩 `제거`하는 것(`꺼내는 것`)을 `Pop` 이라고 합니다.

- 위 그림처럼 Stack은 어느 한 곳에 Block 처럼 자료가 쌓기 때문에
- 자료를 제거 할 때 가장 마지막에 들어간 자료가 가장 먼저 제거 됩니다. (LIFO : Last-in First-Out)

<br/>
<br/>

## ✅ Big O(시간 복잡도)

- 우리가 Stack을 통해 자료를 삽입, 삭제, 검색의 과정을 거친다고 생각해 볼 때
- 컴퓨터에서는 이 과정이 얼마나 걸리는지 정확히 알 수 없습니다.
- 그래서 우리는 어떤 연산을 하는데 몇 차례의 과정이 진행되는지 에 따라
- 소요 시간과 효율성을 측정 할 수 있습니다.
- 이 때 연산 과정을 간편하게 표기해서 쓸 수 있는 수학적인 표기법을 Big O라고 부릅니다

- O(1)의 표현에서 1은 상수 시간을 말합니다.
- 예를 들어 Stack에 자료를 추가 할 경우 항상 Stack의 맨 위에 자료를 Push 하기만 하면 됩니다.
- 즉 자료의 개수가 몇 개 인지 혹은 다른 어떠한 사항도 고려할 필요가 없습니다.
- 그저 자료를 기존의 자료 맨 위에 올리기만 하면 된다는 뜻입니다.
- 그러므로 한번의 Operation으로 자료의 삽입이 수행 되기 때문에 O(1)이라고 표현 할 수 있습니다.
- 단 O(1)은 한 번만 연산이 된다는 의미가 아닙니다.
- 어떤 작업을 수행할 때 마다 항상 동일한 작업만을 수행한다면 작업들을 O(1)로 표현 할 수 있습니다.
- 마찬가지로 자료를 삭제 할 때도 자료의 개수와 상관없이 맨 위에 있는 자료를 Pop하면 되기 때문에
- 자료의 삭제도 O(1)로 표기 할 수 있습니다.

- 그렇다면 자료의 검색은 어떨 까요?
- 만약 Stack에 5개의 블록이 쌓여 있다면 우리는 맨 위의 Block에서 부터 맨 마지막 Block까지 순차적으로 검색하여 자료를 찾아야 합니다.
- 운이 좋게 첫 번째 Block이 우리가 찾는 Block이 있다면 한 번의 검색으로 답을 찾을 수 있겠지만
- 만약에 맨 마지막 Block이 우리가 찾는 Block이라면 우리는 맨 마지막 Block이 나올 때 까지 5번의 검색 과정을 거쳐야 합니다.
- 그러므로 Stack의 검색 횟수는 가장 최악의 경우인 O(n)으로 표기 할 수 있습니다.

<br/>

### ⭐️Stack 예시

- Call Stack : JS는 모든 함수 호출을 Stack 자료 구조로 이루어져 있습니다. 특히 재귀 함수를 사용 할 때 가장 중요하게 다뤄진다.
- Undo / Redo Mechanism : 포토샵의 기능 중 Ctrl+Alt+Z를 눌러 방금 전의 작업들을 뒤에서 부터 순차적으로 취소 할 수 있다. 우리가 실행한 작업들이 순차적으로 Stack 자료 구조로 저장되고, 취소 단축키를 누를 때 마다 맨 위의 자료들이 삭제 되기 때문이다.

<br/>
<br/>
<br/>

## ✅ 3. Linked List(연결 리스트)

- Linked List는 여러 노드들이 연결되어 있는 구조입니다.
- 연결 리스트의 맨 앞을 Head, 맨 마지막을 Tail이라고 합니다.
- 노드들은 다음에 올 노드의 정보를 가지고 있다.

- 만약 연결 리스트에 자료를 삽입하려고 한다면 우리는 위 그림과 같이 자료를 추가할 장소로 가서
- 기존의 링크를 끊은 다음 추가할 위치의 이 전 요소의 꼬리와 삽입할 자료의 꼬리를 연결해야 합니다.
- 그리고 추가할 요소의 꼬리와 다음 요소의 꼬리를 연결해 주면 됩니다.
- 이 때에 오직 앞 요소와 다음 요소와 연결시켜주는 Operation만 수행 되므로 시간 복잡도는 O(1)입니다.

- 만약에 연결 리스트에 특정 자료를 삭제하려고 한다면 위의 그림처럼 삭제하고자 하는 요소의 이전 요소의 꼬리를 다음 요소와 연결 시켜 주면 됩니다.
- 마찬 가지로 삭제하고자 하는 요소의 이전 요소와 다음 요소를 연결시켜주는 Operation이 수행 되므로 시간 복잡도는 O(1)입니다.
- 또한 연결 리스트에서 자료를 검색하고 싶다면 맨 앞의 Head에서 부터 시작해야 합니다.
- 왜냐하면 연결 리스트의 각 노드들은 다음 요소들의 정보를 가지고 있기 때문입니다.
- 그러므로 맨 앞의 리스트 에서 부터 그 다음의 노들로 순차적으로 검색해야 합니다.
- 이 때의 시간 복잡도는 O(n)입니다.

<br/>

### ⭐️Stack 예시

- 웹 브라우저에서 여러 사이트들을 실행하고 난 후 History는 연결 리스트와 같은 구조로 저장됩니다.
- 내가 어떤 사이트들에서 다른 사이트로 넘어갈 때, 이전 사이트의 정보를 가지고 넘어가기 때문입니다.
- 따라서 우리가 브라우저에서 이전 버튼, 다음 버튼, 누르면 이전에, 혹은 다음에 열람 했던 사이트들로 이동 할 수 있습니다.

<br/>
<br/>
<br/>

# 🌈 [자료 구조] Data Structure - Hash Table

- 만약에 친구들 이름과 전화 번호 List 가 있다고 생각해 봅시다.
- 이제 친구들의 이름, 전화번호 Data를 저장해 두었다가 필요 할 때마다
- 친구들의 이름을 입력해서 전화번호 Data를 찾으려고 합니다.
- 이 때 친구들의 전화번호를 가장 빠르게 찾기 위한 방법 중 하나가 바로 `Hash Table`입니다.
- Hash Table을 구성하는 데 Hash Function이 필 수 입니다.
- Hash Function은 친구 이름과 같은 문자열을 받아서 고유한 숫자 키로 변경 해주는 함수 입니다.
- 먼저 10개의 Data를 넣을 경우 10개의 공간을 준비 합니다.
- 각 친구 이름들을 차례 대로 Hash Function을 통해 고유한 숫자 키를 받아 냅니다.
- 예를 들어 Freeko의 숫자 키는 3, Ria의 숫자 키는 1이라고 해봅시다.
- 이 때의 숫자 키 값은 Data 공간의 주소 값이 됩니다.
- 그럼 이제 아까 준비한 공간에 숫자 키를 방 번호로 삼아 전화번호 Data를 집어 넣습니다.
- 이제 내가 Freeko의 전화번호를 알고 싶다면 복잡하게 Loop을 돌리거나 할 필요 없이 단지 Freeko라는 이름을 Hash Function에 넣고 숫자 키를 알아낸 다음 그 방 번호의 Data를 확인하면 아주 쉽게 Freeko의 전화번호를 알아 낼 수 있습니다.

- 즉 `Hash Table` 이란 위의 예시에서 살펴 보았듯이 Hash Function을 사용하여 키 값을 Data 공간의 주소로 변환 하고 해당 주소에 키 값에 대응하는 Data를 넣는 자료 구조를 말합니다.

<br/>

## ✅ Hash Table 장점

- 중복 Data를 찾아 내기 쉬움
- 빠른 탐색, 삽입, 삭제 속도
- 어떤 항목과 다른 항복의 관계를 모형화 하기 좋음

—> 단순 List에 저장한 Data는 중복된 Data를 찾기 위해서 단순 탐색을 계속해서 반복 해야 하기 때문에 성능이 매우 좋지 않습니다. 그러나 Hash Table에 저장하면 Data가 있는지 순간적으로 알려주기 때문에 중복 확인하는 것이 매우 쉬워 집니다.

<br/>

## ✅ Hash Table 단점

- 공간 효율성이 낮음 ( 만약 10개의 자료를 넣기 위해 미리 빈 공간을 만든 다음 2개의 Data만 넣는 다면 8개의 공간이 빈 상태가 됩니다. 또는 11개의 공간을 넣게 되면 overflow가 발생하기 때문에 Data 공간을 크게 늘리고 기존의 Data를 다시 Hashing 해야 합니다.

<br/>

## ✅ Collision

- 충돌이 발생하기 전까지 Hash Table은 성능이 매우 뛰어난 자료 구조 입니다.
- 충돌이란 다른 키 2개를 Hash Function에 넣었는데 같은 주소 값이 나오는 경우를 말합니다.
- 많은 양의 Data를 처리하다 보면 충돌이 발생하는 경우가 생길 수 밖에 없습니다.

<br/>

### ⭐️ Collision 해결 방법 1 : Linked List

- 만약 같은 주소가 나왔을 때 해당 주소에 이미 Data가 있다면 그 Data에 연결 리스트로 연결 합니다.
- 예를 들어 알파벳을 각각 0 ~ 25의 숫자에 대응시킨 후,
- 영어 단어를 입력 하면 맨 앞 글자에 따라 해당 숫자를 Output으로 넘겨주는 Hashing Function 있다고 생각을 해보겠습니다.
- 위 Hash Function을 사용하여 전화번호 Hash Table을 만들면 R로 시작하는 이름을 가진 친구는 전부 같은 주소 값을 갖게 될 것 입니다.
- 이 경우에 해당 주소에 R로 시작하는 친구의 Data를 연결 리스트로 모두 연결하면 됩니다.
- 이 방법의 단점은 충돌 횟수가 늘어나 연결 리스트의 길이가 길어 질 수록 Hash Table의 성능이 매우 낮아진다는 것 입니다.
- Hash Table은 Data를 빨리 찾고 삭제하고 입력 할 수 있는 장점이 있는데 연결 리스트가 길어지면 연결 리스트를 순회하는 과정 탓에 성능이 떨어지게 됩니다.

<br/>

### ⭐️ Collision 해결 방법 2 : Linear Probing(선형 탐사)

- 선형 탐사는 충돌이 발생한 지점의 다음 방 부터 탐사하여 빈 방이 있으면 그 공간에 Data를 집어 넣는 방법입니다.
- 만약 끝까지 탐색 했는데 빈 공간이 없다면 맨 처음으로 돌아가 다시 검사합니다.
- 매우 간단 하지만 만약에 주변에 Data 공간이 비어 있지 않다면 빈 공간을 찾기 위해 모든 공간을 탐색해야 하는 단점이 있습니다.

<br/>

## ✅ Big O

- 삽입 ( Insertion ) : O(1)
- 삭제 ( Deletion ) : O(1)
- 탐색 ( Search ) : O(1)
- Data를 추가 할 때, 그저 Hash Function에 Key를 넣어 주소를 알아 낸 후 해당 주소에 Data를 삽입하면 되기 때문에 O(1)의 상수 시간으로 표기 할 수 있습니다. Data를 검색, 삭제할 때도 마찬 가지 입니다.

### ‼️여기서 상수 시간(Constant Time) 이란

- 순간적 혹은 연산이 한 번만 일어 난다는 것이 아닙니다.
- 항상 똑같은 시간이 걸린다는 뜻 입니다.
- 예를 들어 단순한 List에 어떤 Data를 단순 탐색으로 찾으려면 앞에서 부터 검색을 해야 하기 때문에 O(n) 만큼 소요 됩니다.
- 이 때의 n은 List의 길이를 뜻합니다. 만약 이진 탐색을 한다면 좀 더 빠르게 log 시간이 걸릴 것 입니다.
- 그러나 Hash Table에서 Data를 찾으면 Table의 Data가 1개든 5개든 100개든 크기와 아무 상관 없이 Data 하나를 꺼내는 시간은 모두 동일 합니다. 그러므로 평균적으로 Hash Table은 아주 빠릅니다.
- 하지만 최악의 경우에 Hash Table은 Data의 탐색, 삽입, 삭제가 모두 O(n)만큼의 시간이 소요 됩니다. 최악의 상황이 발생하지 않으려면 충돌을 최대한 피해야 하는데, 그러기 위해 좋은 Hash Funtion와 낮은 사용률이 필요 합니다.

<br/>

## ✅ Load Factor(사용률)

- Hash Table에서 사용률이란 Hash Table의 공간을 얼마나 사용하고 있는지 수식으로 나타낸 것입니다.

- 만약에 배열에서 5개의 방이 있는데 그 중 2개의 공간에 Data가 저장되어 있다면 2 / 5 = 0.4가 사용률 됩니다.
- 그리고 100개의 Data가 있는데 공간이 50개 밖에 없다면 사용률은 2가 되고 절반의 Data는 공간이 없게 됩니다. 즉, 사용률이 1보다 크다는 것은 Hash Table의 공간이 부족하다는 뜻 입니다.
- 대개의 경우 사용률이 0.7 이상으로 커지면 Hash Table을 Resizing하는데 대략 2배 정도의 크기로 배열을 만듭니다.
- Resizing을 하면 배열을 크게 만들고 나면 Hash Function을 사용하여 기존 Table에 있던 Data를 새로운 Hash Table에 다시 저장해야 합니다. 이 과정은 시간 매우 오래 걸리기 때문에 Resizing을 자주 하는 것은 좋지 않습니다.

<br/>

## ✅ Hashing

- Hashing이란 어떤 길이든지 상관 없이 input string을 받아 고정된 길이의 결과물로 만들어 주는 것입니다.
- 비트코인도 SHA-256이란 Hashing 알고리즘을 사용합니다.

<br/>

## ✅ Hash Function

- Hash Function은 반드시 동일한 input이 들어가면 항상 동일한 output이 나와야 합니다.
- Hash Function를 사용 할 때마다 매번 다른 결과가 나온다면 그 Hash Table은 사용할 수 없을 것 입니다.
- Hash Function은 값이 골고루 분포되어야 합니다. 만약 한 쪽으로 쏠려서 Data가 분배되면 충돌이 자주 발생합니다.
- Hash Function은 성능이 뛰어나야 합니다. Hash Function의 성능은 Hash Table의 성능과 직접적인 연관이 있기 때문입니다.

<br/>

## ✅ Real Life Use Cases

- 주소록
- 블록 체인
- JS 실행 엔진 ( 크롬, V8 )
- 웹 사이트를 찾기 위해서 웹사이트 주소를 브라우저에 입력 한다고 해보자. 우리의 컴퓨터는 우리가 입력한 주소를 IP 주소로 변환 한다. 밑에 처럼 말이다.

GOOGLE.COM - 74.125.239.133

FACEBOOK.COM - 173.252.120.6

- 이러한 과정은 DNS 확인 (DNS resolution) 작업이라고 하는 데 이러한 작업에도 Hash Table이 사용됩니다.
