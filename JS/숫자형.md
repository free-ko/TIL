# 숫자형

- JS는 숫자를 나타내는 2가지 자료형을 지원합니다.

1. 일반적인 숫자는 '배정밀도 부동소수점 숫자(double precision floating point number)'로 알려진 64비트 형식의 IEEE-754에 저장됩니다
2. 임의의 길이를 가진 정수는 BigInt 숫자로 나타낼 수 있습니다. 일반적인 숫자는 253이상이거나 -253이하일 수 없다는 제약 때문에 BigInt라는 새로운 자료형이 만들어졌습니다.(BigInt는 아주 특별한 경우에만 사용됩니다.)

## 숫자를 입력하는 다양한 방법

- 10익(billion)을 나타낼 땐 `1bn`을 사용합니다.
- `e`를 붙이고 0의 개수를 그 옆에 붙여주면 숫자를 줄일 수 있습니다.

```js
let billion = 1e9;

let 1e3 = 1 * 1000
1.23e6 = 1.23 * 1000000
```

```js
let ms = 0.00001;

// 작은 숫자를 표현 할 때도 큰 숫자를 표현 할 때처럼 e를 사용 할 수 있습니다.
let ms = 1e-6;
```

<br>

## 16진수, 2진수, 8진수

- 16진수는 `색을 나타내거나`, `문자를 인코딩 할 때` 등 다양한 곳에 사용 합니다.
- `0x`를 사용해 표현 할 수 있습니다.

```js
alert(0xff); // 255
alert(0xff); // 255 (대, 소문자를 가리지 않으므로 같은 값을 나타냅니다.)
```

<br>

- 2진수와 8진수는 아주 드물게 쓰이긴 하지만, 접두사 `0b`와 `0o`를 사용해 간단히 나타낼 수 있습니다.

```js
let a = 0b111111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert(a == b); // true, 진법은 다르지만, a와 b는 같은 수
```

- JS에서 지원하는 진법은 3개 입니다. 이 외의 진법을 사용하려면 함수 `pareeInt`를 사용해야 합니다.

<br>

## toString(base)

- `num.toString(base)` 메서드는 `base`진법으로 `num`을 표현한 후, 이를 문자형으로 반환 합니다.
- `base`는 2에서 36까지 쓸 수 있는데, 기본 값은 10입니다.
- `base`별 유스 케이스는 다음과 같습니다.

  1. `base=16` – 16진수 색, 문자 인코딩 등을 표현할 때 사용합니다. 숫자는 0부터 9, 10 이상의 수는 A부터 F를 사용하여 나타냅니다
  2. `base=2` – 비트 연산 디버깅에 주로 쓰입니다. 숫자는 0 또는 1이 될 수 있습니다.
  3. `base=36` – 사용할 수 있는 base 중 최댓값으로, 0..9와 A..Z를 사용해 숫자를 표현합니다. 알파벳 전체가 숫자를 나타내는 데 사용되죠. 36 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용합니다.

  ```js
  alert((123456).toString(36)); // 2n9c

  // 점 두개와 메서드 호출
  // 123456..toString(36)에 있는 점 두 개는 오타가 아닙니다. 위 예시처럼 숫자를 대상으로 메서드 toString을 직접 호출하고 싶다면 숫자 다음에 점 두 개 ..를 붙여야 합니다.
  // 123456.toString(36)처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있습니다. 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출합니다.
  // (123456).toString(36)도 가능합니다.
  ```

```js
let num = 255;

alert(num.toString(16)); // ff
alert(num.toString(2)); //  11111111
```

<br>

## 어림 수 구하기

- 어림수를 구하는 것(rounding)은 숫자를 다룰 때 가장 많이 사용되는 연산 중 하나입니다.

1. `Math.floor` : 소수점 첫째 자리에서 내림(버림). 3.1은 3, -1.1은 -2가 됩니다.
2. `Math.ceil` : 소수점 첫째 자리에서 올림. 3.1은 4, -1.1은 -1이 됩니다.
3. `Math.round `: 소수점 첫째 자리에서 반올림. 3.1은 3, 3.6은 4, -1.1은 -1이 됩니다.
4. `Math.trunc` (Internet Explorer에서는 지원하지 않음) : 소수부를 무시. 3.1은 3이 되고 -1.1은 -1이 됩니다.

<br>

## 부정확한 계산

- 숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요합니다.
- 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용됩니다.
- 그런데 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리됩니다.

```js
alert(0.1 + 0.2 == 0.3); // false
alert(0.1 + 0.2); // 0.30000000000000004
```

<br>

- 부정확한 비교 연산이 만들어내는 결과는 여기서 그치지 않습니다.
- 인터넷 쇼핑몰 사이트를 운영하고 있다고 가정해 봅시다. 사용자가 $0.10와 $0.20 짜리 물품을 장바구니에 넣었다고 상상해 보죠. 주문 총액이 $0.30000000000000004인 것을 보고 놀라지 않을 사용자는 없을 겁니다.

- `왜 이런 일이 발생하는 걸까요?`
- `숫자는 0과 1로 이루어진 이진수`로 변환되어 `연속된 메모리 공간`에 저장됩니다.
- 그런데 10진법을 사용하면 쉽게 표현할 수 있는 0.1, 0.2 같은 분수는 이진법으로 표현하면 무한 소수가 됩니다.
- 0.1은 1을 10으로 나눈 수인 1/10입니다. 10진법을 사용하면 이러한 숫자를 쉽게 표현할 수 있죠.
- 1/10과 1/3을 비교해봅시다. 1/3은 무한 소수 0.33333(3)이 됩니다.
- 이렇게 10의 거듭제곱으로 나눈 값은 10진법에서 잘 동작하지만 3으로 나누게 되면 10진법에서 제대로 동작하지 않습니다.
- 같은 이유로 2진법 체계에서 2의 거듭제곱으로 나눈 값은 잘 동작하지만 1/10같이 2의 거듭제곱이 아닌 값으로 나누게 되면 무한 소수가 되어버립니다.
- `10진법에서 1/3을 정확히 나타낼 수 없듯이`, `2진법을 사용해 0.1 또는 0.2를 정확하게 저장하는 방법은 없습니다.`
- IEEE-754에선 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결합니다.

### JS뿐만이 아닙니다.

- 다른 언어에서도 같은 이슈가 있습니다.
- 자바스크립트와 동일한 숫자 형식을 사용하기 때문에 PHP, Java, C, Perl, Ruby에서도 똑같은 결과를 얻습니다.

<br>

- 문제를 해결하는 방법은 없을까요? 물론 있습니다. 가장 신뢰할만한 방법은 `toFixed(n)메서드를 사용해 어림수`를 만드는 것입니다.

```js
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30

// 숫자에 임시로 100(또는 더 큰 숫자)을 곱하여 정수로 바꾸고,
// 원하는 연산을 한 후 다시 100으로 나누는 것도 하나의 방법이 될 수 있습니다.
// 정수를 대상으로 하는 수학 연산은 소수를 대상으로 하는 연산보다 에러가 적기 때문입니다.
// 그런데 어쨌든 마지막에 나눗셈이 들어가기 때문에 소수가 다시 등장할 수 있다는 단점이 있습니다.

alert((0.1 * 10 + 0.2 * 10) / 10); // 0.3
alert((0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001

// 이렇게 10의 거듭제곱을 곱하고 다시 동일한 숫자로 나누는 전략은 오류를 줄여주긴 하지만 완전히 없애지는 못합니다.
// 구현을 하다 보면 무한 소수가 나오는 경우를 완전히 차단해야 하는 경우가 생기곤 합니다.
// 달러가 아닌 센트 단위로 물품 가격을 저장하는 쇼핑몰을 담당하고 있는데, 행사 때문에 가격을 30% 할인해야 하는 경우가 그렇죠.
// 무한소수를 방지하는 완벽한 방법은 사실 없습니다. 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이죠.
```

<br>

### 흥미로운 발견

```js
// 숫자가 스스로 증가하네요!
alert(9999999999999999); // 10000000000000000이 출력됩니다.

// 문제의 원인은 역시나 정밀도 손실 때문입니다.
// 숫자를 저장할 땐 64비트가 사용되는데, 이 중 실제 숫자를 저장하는 데 사용되는 52비트에 위 숫자를 저장하기엔 공간이 모자랍니다.
// 따라서 최소 유효 숫자(the least significant digit)가 손실되어 버렸습니다.
// 자바스크립트는 숫자 손실이 일어나도 오류를 발생시키지 않습니다.
// 적절한 포맷으로 숫자를 맞추는 데 최선을 다하긴 하지만 유감스럽게도 위 예시의 숫자를 담기엔 포맷이 충분하지 않네요.
```

<br>

### 두 종류의 0

- 자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은 `0과 -0이라는 두 종류의 0이 존재한다는 사실입니다.`
- 자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문입니다.
- 대부분의 연산은 0과 -0을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는 편입니다.

<br>

## isNaN과 isFinite

- `Infinity와 -Infinity` – 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
- `NaN` – 에러를 나타내는 값
- 두 특수 숫자는 `숫자형`에 속하지만 `정상적인`숫자는 아니기 때문에, `정상적인 숫자와 구분하기 위한 특별한 함수`가 존재합니다.

1. `isNaN(value)` – 인수를 숫자로 변환한 다음 NaN인지 테스트함

```js
alert(isNaN(NaN)); // true
alert(isNaN("str")); // true
```

- 그런데 굳이 이 함수가 필요할까요? "`=== NaN`비교를 하면 되지 않을까?"라는 생각이 들 수 있습니다.
- 안타깝게도 대답은 '필요하다’입니다. `NaN은 NaN 자기 자신을 포함하여 그 어떤 값과도 같지 않다`는 점에서 독특합니다.

```js
alert(NaN === NaN); // false
```

<br>

2. `isFinite(value)` – 인수를 `숫자`로 변환하고 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 true를 반환함

```js
alert(isFinite("15")); // true
alert(isFinite("str")); // false, NaN이기 때문입니다.
alert(isFinite(Infinity)); // false, Infinity이기 때문입니다.
```

- `isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 합니다.

```js
let num = +prompt("숫자를 입력하세요.", "");

// 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력됩니다.
alert(isFinite(num));
```

- 빈 문자열이나 공백만 있는 문자열은 isFinite를 포함한 모든 숫자 관련 내장 함수에서 0으로 취급된다는 점에 유의하시기 바랍니다.

<br>

### Object.is와 비교하기

- `Object.is`는 `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드인데, 아래와 같은 두 가지 에지 케이스에선 `===`보다 좀 더 신뢰할만한 결과를 보여줍니다.
- `NaN`을 대상으로 비교할 때: `Object.is(NaN, NaN) === true`임.
- `0`과 `-0`이 다르게 취급되어야 할 때: `Object.is(0, -0) === false`임. 숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트는 다르므로 0과 -0은 사실 다른 값이긴 합니다.
- 이 두 에지 케이스를 제외하곤, `Object.is(a, b)`와 `a === b`의 결과는 같습니다.
- 이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있습니다.
- 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우 `Object.is`를 사용하죠. `Object.is`에서 사용되는 비교방식은 명세서에서 `SameValue`라고 불립니다.

<br>

## parseInt와 parseFloat

- 단항 덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때 적용되는 규칙은 꽤 엄격합니다. 피연산자가 숫자가 아니면 형 변환이 실패합니다.

```js
alert(+"100px"); // NaN
```

- 엄격한 규칙이 적용되지 않는 유일한 예외는 문자열의 처음 또는 끝에 공백이 있어서 공백을 무시할 때입니다.
- 그런데 실무에선 CSS 등에서 '100px', '12pt'와 같이 숫자와 단위를 함께 쓰는 경우가 흔합니다.
- 대다수 국가에서 '19€'처럼 금액 뒤에 통화 기호를 붙여 표시하기도 하죠. 숫자만 추출하는 방법이 필요해 보이네요.

<br>

- 내장 함수 `parseInt`와 `parseFloat`는 이런 경우를 위해 만들어졌습니다.
- 두 함수는 불가능할 때까지 문자열에서 숫자를 ‘읽습니다’. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환하죠.
- `parseInt는 정수`, `parseFloat는 부동 소수점 숫자`를 반환합니다.

```js
alert(parseInt("100px")); // 100
alert(parseFloat("12.5em")); // 12.5

alert(parseInt("12.3")); // 12, 정수 부분만 반환됩니다.
alert(parseFloat("12.3.4")); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.
```

```js
// parseInt와 parseFloat가 NaN을 반환할 때도 있습니다. 읽을 수 있는 숫자가 없을 때 그렇죠.

alert(parseInt("a123")); // NaN, a는 숫자가 아니므로 숫자를 읽는 게 중지됩니다.
```

<br>

### `parseInt(str, radix)의 두번째 인수

- `parseInt()`의 두 번째 매개 변수는 선택적으로 사용할 수 있습니다.
- `radix`는 원하는 `진수`를 지정해 줄 때 사용합니다.
- 따라서 parseInt를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있습니다.

```js
alert(parseInt("0xff", 16)); // 255
alert(parseInt("ff", 16)); // 255, 0x가 없어도 동작합니다.
alert(parseInt("2n9c", 36)); // 123456
```

<br>

## 기타 수학 함수

- `Math.random()` : 0과 1 사이의 난수를 반환합니다(1은 제외).
- `Math.max(a, b, c...)` / `Math.min(a, b, c...)` : 인수 중 `최대/최솟값`을 반환합니다.
- `Math.pow(n, power)` : n을 power번 거듭제곱한 값을 반환합니다

<br>

## 요약

- 0이 많이 붙은 큰 숫자는 다음과 같은 방법을 사용해 씁니다.
  - 0의 개수를 `'e'` 뒤에 추가합니다. `123e6`은 0이 6개인 숫자, `123000000`을 나타냅니다.
  - `'e'` 다음에 음수가 오면, 음수의 절댓값 만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눕니다. `123e-6`은 `0.000123`을 나타냅니다.
- 다양한 진법을 사용할 수도 있습니다.
  - 자바스크립트는 특별한 변환 없이 `16진수(0x)`, `8진수(0o)`, `2진수(0b)`를 바로 사용할 수 있게 지원합니다.
  - `parseInt(str, base)`를 사용하면 `str`을` `base진수`로 바꿔줍니다(단, 2 ≤ base ≤ 36).
  - `num.toString(base)`는 `숫자를 base진수`로 바꾸고, 이를 `문자열` 형태로 반환합니다.
  - `12pt`나 `100px`과 같은 값을 `숫자로 변환`하는 것도 가능합니다.
  - `parseInt/parseFloat`를 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 ‘약한’ 형 변환을 사용할 수 있습니다.
- 소수를 처리하는 데 쓰이는 메서드는 다음과 같습니다.
  - `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round`, `num.toFixed(precision)`를 사용하면 어림수를 구할 수 있습니다.
  - 소수를 다룰 땐 정밀도 손실에 주의하세요.
  
 <br>
 
 [출처]
 https://ko.javascript.info/number#ref-998
