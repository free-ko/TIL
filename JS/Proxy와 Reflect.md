# Proxy와 Reflect

- `Proxy`는 특정 객체를 감싸 프로퍼티 읽기, 쓰기와 같은 객체에 가해지는 작업을 중간에서 가로채는 객체로, 가로채진 작업은 `Proxy` 자체에서 처리되기도 하고, 원래 객체가 처리하도록 그대로 전달되기도 합니다.
- 프락시는 다양한 라이브러리와 몇몇 브라우저 프레임워크에서 사용되고 있습니다.

<br>

## Proxy

```js
let proxy = new Proxy(target, handler);
```

- `target` : 감싸게 될 객체로, 함수를 포함한 모든 객체가 가능합니다.
- `handler` : 동작을 가로채는 메서드인 `'트랩(trap)'`이 담긴 객체로, 여기서 프락시를 설정합니다(예시: `get` 트랩은 `target`의 프로퍼티를 읽을 때, `set` 트랩은 `target`의 프로퍼티를 쓸 때 활성화됨).
- `proxy`에 작업이 가해지고, `handler`에 작업과 상응하는 트랩이 있으면 트랩이 실행되어 프락시가 이 작업을 처리할 기회를 얻게 됩니다.
- 트랩이 없으면 `target`에 작업이 직접 수행됩니다.
- 먼저, 트랩이 없는 프락시를 사용한 예시를 살펴봅시다.

```js
let target = {};
let proxy = new Proxy(target, {}); // 빈 핸들러

proxy.test = 5; // 프락시에 값을 씁니다. -- (1)
alert(target.test); // 5, target에 새로운 프로퍼티가 생겼네요!

alert(proxy.test); // 5, 프락시를 사용해 값을 읽을 수도 있습니다. -- (2)

for (let key in proxy) alert(key); // test, 반복도 잘 동작합니다. -- (3)
```

- 위 예시의 프락시엔 트랩이 없기 때문에 `proxy`에 가해지는 모든 작업은 `target`에 전달됩니다.

1. `proxy.test=`를 이용해 값을 쓰면 `target`에 새로운 값이 설정됩니다.
2. `proxy.test`를 이용해 값을 읽으면 `target`에서 값을 읽어옵니다.
3. `proxy`를 대상으로 반복 작업을 하면 `target`에 저장된 값이 반환됩니다.

- 트랩이 없으면 `proxy`는 `target`을 둘러싸는 투명한 래퍼가 됩니다.
- `Proxy`는 일반 객체와는 다른 행동 양상을 보이는 `'특수 객체(exotic object)'`입니다.
- 프로퍼티가 없죠. `handler`가 비어있으면 `Proxy`에 가해지는 작업은 `target`에 곧바로 전달됩니다.
- 자 이제 트랩을 추가해 Proxy의 기능을 활성화해봅시다.
- 그 전에 먼저, 트랩을 사용해 가로챌 수 있는 작업은 무엇이 있는지 알아봅시다.
- 객체에 어떤 작업을 할 땐 자바스크립트 명세서에 정의된 `'내부 메서드(internal method)'`가 깊숙한 곳에서 관여합니다.
- 프로퍼티를 읽을 땐 `[[Get]]`이라는 내부 메서드가, 프로퍼티에 쓸 땐 `[[Set]]`이라는 내부 메서드가 관여하게 되죠.
- 이런 내부 메서드들은 명세서에만 정의된 메서드이기 때문에 개발자가 코드를 사용해 호출할 순 없습니다.
- 프락시의 트랩은 내부 메서드의 호출을 가로챕니다. 프락시가 가로채는 내부 메서드 리스트는 명세서에서 확인할 수 있습니다.
- 모든 내부 메서드엔 대응하는 트랩이 있습니다.

<br>

[출처]
https://ko.javascript.info/proxy
