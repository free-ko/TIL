# 모듈 내보내고 가져오기

- `export`와 `import` 지시자는 다양한 방식으로 활용됩니다.
- `export`와 `import`의 기본적인 사용법을 알아보았는데, 이번 챕터에선 좀 더 다양한 사용법을 배워보겠습니다.

<br>

## 선언부 앞에 export 붙이기

- 변수나 함수, 클래스를 선언할 때 맨 앞에 `export`를 붙이면 내보내기가 가능합니다.

```js
// 배열 내보내기
export let months = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec",
];

// 상수 내보내기
export const MODULES_BECAME_STANDARD_YEAR = 2015;

// 클래스 내보내기
export class User {
  constructor(name) {
    this.name = name;
  }
}
```

<br>

### 클래스나 함수를 내보낼 땐 세미콜론을 붙이지 마세요.

- 클래스나 함수 선언 시, 선언부 앞에 `export`를 붙인다고 해서 함수 선언 방식이 함수 선언문에서 함수 표현식(function expression) 으로 바뀌지 않습니다.
  내보내 지긴 했지만 여전히 함수 선언문입니다.
- 대부분의 자바스크립트 스타일 가이드는 함수나 클래스 선언 끝에 세미콜론을 붙이지 말라고 권유합니다.
- 같은 이유로 `export class`나 `export function` 끝에 세미콜론을 붙이지 않습니다.

```js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
} // 끝에 ;(세미콜론)을 붙이지 않습니다.
```

<br>

## 선언부와 떨어진 곳에 export 붙이기

- 선언부와 `export`가 떨어져 있어도 내보내기가 가능합니다.
- 아래 예시에선 함수를 먼저 선언한 후, 마지막 줄에서 내보냅니다.

```js
// 📁 say.js
function sayHi(user) {
  alert(`Hello, ${user}!`);
}

function sayBye(user) {
  alert(`Bye, ${user}!`);
}

export { sayHi, sayBye }; // 두 함수를 내보냄
```

- 참고로 `export`문을 함수 선언부 위에 적어주는 것도 동일하게 동작합니다.

<br>

## import \*

- 무언갈 가져오고 싶다면 아래와 같이 이에 대한 목록을 만들어 `import {...}`안에 적어주면 됩니다.

```js
// 📁 main.js
import { sayHi, sayBye } from "./say.js";

sayHi("John"); // Hello, John!
sayBye("John"); // Bye, John!
```

- 가져올 것이 많으면 `import * as <obj>` 처럼 객체 형태로 원하는 것들을 가지고 올 수 있습니다. 예시를 살펴보겠습니다.

```js
// 📁 main.js
import * as say from "./say.js";

say.sayHi("John");
say.sayBye("John");
```

- 이렇게 '한꺼번에 모든 걸 가져오는 방식’을 사용하면 코드가 짧아집니다. 그런데도 어떤 걸 가져올 땐 그 대상을 구체적으로 명시하는 게 좋습니다.
- 이렇게 하는 데는 몇 가지 이유가 있습니다.

1. 웹팩(webpack)과 같은 모던 빌드 툴은 로딩 속도를 높이기 위해 모듈들을 한데 모으는 번들링과 최적화를 수행합니다. 이 과정에서 사용하지 않는 리소스가 삭제되기도 합니다.

- 아래와 같이 프로젝트에 서드파티 라이브러리인 `say.js`를 도입하였다 가정합시다. 이 라이브러리엔 수 많은 함수가 있습니다.

```js
// 📁 say.js
export function sayHi() { ... }
export function sayBye() { ... }
export function becomeSilent() { ... }
```

- 현재로선 `say.js`의 수 많은 함수 중 단 하나만 필요하기 때문에, 이 함수만 가져와 보겠습니다.

```js
// 📁 main.js
import { sayHi } from "./say.js";
```

- 빌드 툴은 실제 사용되는 함수가 무엇인지 파악해, 그렇지 않은 함수는 최종 번들링 결과물에 포함하지 않습니다.
- 이 과정에서 불필요한 코드가 제거되기 때문에 빌드 결과물의 크기가 작아집니다. 이런 최적화 과정은 `'가지치기(tree-shaking)'`라고 불립니다.

2. 어떤 걸 가지고 올지 명시하면 이름을 간결하게 써줄 수 있습니다. `say.sayHi()`보다 `sayHi()`가 더 간결하네요.
3. 어디서 어떤 게 쓰이는지 명확하기 때문에 코드 구조를 파악하기가 쉬워 리팩토링이나 유지보수에 도움이 됩니다.

<br>

## import ‘as’

<br>

[출처]
https://ko.javascript.info/import-export
