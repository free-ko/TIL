# 프로토타입 메서드와 **proto**가 없는 객체

- `__proto__`는 브라우저를 대상으로 개발하고 있다면 다소 구식이기 때문에 더는 사용하지 않는 것이 좋습니다. 표준에도 관련 내용이 명시되어있습니다.
- 대신 아래와 같은 모던한 메서드들을 사용하는 것이 좋죠.
- `Object.create(proto, [descriptors])` – `[[Prototype]]`이 `proto`를 참조하는 빈 객체를 만듭니다. 이때 프로퍼티 설명자를 추가로 넘길 수 있습니다.
- `Object.getPrototypeOf(obj)` – `obj`의 `[[Prototype]]`을 반환합니다.
- `Object.setPrototypeOf(obj, proto)` – `obj`의 `[[Prototype]]`이 `proto`가 되도록 설정합니다.
- 앞으론 아래 예시처럼 `__proto__` 대신 이 메서드들을 사용하도록 합시다.

```js
let animal = {
  eats: true,
};

// 프로토타입이 animal인 새로운 객체를 생성합니다.
let rabbit = Object.create(animal);

alert(rabbit.eats); // true

alert(Object.getPrototypeOf(rabbit) === animal); // true

Object.setPrototypeOf(rabbit, {}); // rabbit의 프로토타입을 {}으로 바꿉니다.
```

- 메서드를 소개할 때 잠시 언급한 것처럼 `Object.create`에는 프로퍼티 설명자를 선택적으로 전달할 수 있습니다.
- 설명자를 이용해 새 객체에 프로퍼티를 추가해 보겠습니다.

```js
let animal = {
  eats: true,
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true,
  },
});

alert(rabbit.jumps); // true
```

- 설명자는 프로퍼티 플래그와 설명자에서 배운 것과 같은 형태로 사용하면 됩니다.
- `Object.create`를 사용하면 `for..in`을 사용해 프로퍼티를 복사하는 것보다 더 효과적으로 객체를 복제할 수 있습니다.

```js
let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

- `Object.create`를 호출하면 `obj`의 모든 프로퍼티를 포함한 완벽한 사본이 만들어집니다, 사본엔 열거 가능한 프로퍼티와 불가능한 프로퍼티, 데이터 프로퍼티, `getter`, `setter` 등 모든 프로퍼티가 복제됩니다. `[[Prototype]]`도 복제되죠.

<br>

## 비하인드 스토리

- `[[Prototype]]`을 다룰 수 있는 방법은 다양합니다.
- 목표는 하나인데 목표를 이루기 위한 수단은 여러 가지이네요!
- 왜 그럴까요? 역사적인 이유가 있습니다.
- 생성자 함수의 `"prototype"` 프로퍼티는 아주 오래전부터 그 기능을 수행하고 있었습니다.
- 그런데 2012년, 표준에 `Object.create`가 추가되었죠.
- `Object.create`를 사용하면 주어진 프로토타입을 사용해 객체를 만들 수 있긴 하지만, 프로토타입을 얻거나 설정하는것은 불가능했습니다.
- 그래서 브라우저는 비표준 접근자인 `__proto__`를 구현해 언제나 프로토타입을 얻거나 설정할 수 있도록 하였죠.
- 이후 2015년에 `Object.setPrototypeOf`와 `Object.getPrototypeOf`가 표준에 추가되면서 `__proto__`와 동일한 기능을 수행할 수 있게 되었습니다.
- 그런데 이 시점엔 `__proto__`가 모든 곳에 구현되어 있어서 사실상 표준(`de-facto standard`)이 되어버렸죠.
- 표준의 부록 B(Annex B)에 추가되기도 하였습니다. 이 부록에 추가되면 브라우저가 아닌 환경에선 선택사항이라는것을 의미합니다.
- 이런 이유 때문에 지금은 여러 방식을 원하는 대로 쓸 수 있게 된 것입니다.
- 그런데 "왜 `__proto__`가 함수 `getPrototypeOf/setPrototypeOf`로 대체되었을까?"라는 의문이 떠오를 수 있습니다.
- 흥미로운 질문이죠. 답은 `__proto__`가 왜 나쁜지 이해하면 얻을 수 있습니다. 아래 내용을 계속 읽으면서 답을 찾아봅시다.

<br>

### 속도가 중요하다면 기존 객체의 [[Prototype]]을 변경하지 마세요.

- 원한다면 언제나 `[[Prototype]]`을 얻거나 설정할 수 있습니다.
- 기술적인 제약이 있는 건 아니죠.
- 하지만 대개는 객체를 생성할 때만 `[[Prototype]]`을 설정하고 이후엔 수정하지 않습니다.
- `rabbit`이 `animal`을 상속받도록 설정하고 난 이후엔 이를 변경하지 않죠.
- 자바스크립트 엔진은 이런 시나리오를 토대로 최적화되어 있습니다.
- `Object.setPrototypeOf`나 `obj.__proto__=`를 써서 프로토타입을 그때그때 바꾸는 연산은 객체 프로퍼티 접근 관련 최적화를 망치기 때문에 매우 느립니다.
- 그러므로 `[[Prototype]]`을 바꾸는 것이 어떤 결과를 초래할지 확실히 알거나 속도가 전혀 중요하지 않은 경우가 아니라면 `[[Prototype]]`을 바꾸지 마세요.

<br>

## '아주 단순한' 객체
