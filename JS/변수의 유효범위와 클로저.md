# 변수의 유효 범위와 클로저

- 자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유도를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.
- 함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.
- 그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 함수는 새로운 값을 가져올까요? 아니면 생성 시점 이전의 값을 가져올까요?
- 매개변수를 통해 함수를 넘기고 이 함수를 저 멀리 떨어진 코드에서 호출할 땐 어떤 일이 발생할까요? 함수는 호출되는 곳을 기준으로 외부 변수에 접근할까요?
- 이젠 이런 간단한 시나리오부터 시작해 좀 더 복잡한 시나리오를 다룰 수 있도록 지식을 확장해 봅시다

<br>

## 코드 블록

- 코드 블록 {...} 안에서 선언한 변수는 블록 안에서만 사용할 수 있습니다.

```js
{
  // 지역 변수에 몇 가지 조작을 하면, 그 결과를 밖에선 볼 수 없습니다.

  let message = "Hello"; // 블록 내에서만 변숫값을 얻을 수 있습니다.

  alert(message); // Hello
}

alert(message); // ReferenceError: message is not defined

// 이런 특징은 고유한 작업을 수행하는 코드를 한데 묶는 용도로 활용할 수 있습니다. 이 블록 안엔 해당 작업을 수행하기 위해 사용된 변수가 들어갑니다.
```

<br>

### 블록이 없으면 에러가 발생할 수 있습니다.

```js
// 메시지 출력
let message = "안녕하세요.";
alert(message);

// 또 다른 메시지 출력
let message = "안녕히 가세요."; // SyntaxError: Identifier 'message' has already been declared
alert(message);
```

<br>

### `if, for, while` 등에서도 마찬가지로 `{...}` 안에서 선언한 변수는 오직 블록 안에서만 접근 가능합니다.

```js
if (true) {
  let phrase = "안녕하세요!";

  alert(phrase); // 안녕하세요!
}

alert(phrase); // ReferenceError: phrase is not defined

// if 블록 아래에 있는 alert에선 phrase에 접근할 수 없기 때문에 위 예시를 실행하면 에러가 발생합니다.
// 이런 특징은 변수의 범위를 블록 범위, 특히 if 분기문 범위로 한정시킬 수 있어서 아주 유용합니다.
// if 뿐만 아니라 for, while 반복문에서도 동일한 특징이 적용됩니다.

for (let i = 0; i < 3; i++) {
  // 변수 i는 for 안에서만 사용할 수 있습니다.
  alert(i); // 0, 1, 2가 출력
}

alert(i); // ReferenceError: i is not defined

// let i는 {...} 밖에 있긴 하지만 for 옆 괄호 안에서 선언한 변수는 블록 {...}에 속하는 코드로 취급된다는 점에서 조금 특별합니다.
```

<br>

## 중첩 함수

- 함수 내부에서 선언한 함수는 ‘중첩(nested)’ 함수라고 부릅니다.
- 바스크립트에선 중첩 함수를 손쉽게 만들 수 있습니다.
- 중첩 함수는 아래와 같이 코드를 정돈하는데 사용할 수 있습니다.

```js
function sayHiBye(firstName, lastName) {
  // 헬퍼(helper) 중첩 함수
  function getFullName() {
    return firstName + " " + lastName;
  }

  alert("Hello, " + getFullName());
  alert("Bye, " + getFullName());

  // 위 예시에서 외부 변수에 접근해 이름 전체를 반환해주는 중첩 함수 getFullName()은 편의상 만든 함수입니다. 이렇게 자바스크립트에선 중첩 함수가 흔히 사용됩니다.
  // 중첩 함수는 반환될 수 있다는 점에서 흥미롭습니다. 새로운 객체의 프로퍼티 형태로나 중첩 함수 그 자체로 반환되죠. 이렇게 반환된 함수는 어디서든 호출해 사용할 수 있습니다. 물론 이때도 외부 변수에 접근할 수 있다는 사실은 변함없습니다.
}
```

<br>

```js
// 아래 함수 makeCounter는 숫자를 세주는 ‘카운터’ 함수를 만듭니다. 카운터 함수는 호출될 때마다 다음 숫자를 반환합니다.

function makeCounter() {
  let count = 0;

  return function () {
    return count++;
  };
}

let counter = makeCounter();

alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2

// 예시의 makeCounter는 아주 단순하지만, 여기에 약간의 변형을 가하면 난수 생성기 같은 실용성 있는 함수를 만들 수 있습니다.
// 그런데 makeCounter를 살펴보다 보면 “counter를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 함수와 중첩 함수 내 count 변수엔 어떤 값이 할당될까?” 같은 의문이 들기 마련입니다.
```

<br>

[출처]
https://ko.javascript.info/closure
