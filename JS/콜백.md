# 콜백

- 자바스크립트 호스트 환경이 제공하는 여러 함수를 사용하면 비동기(asynchronous) 동작을 스케줄링 할 수 있습니다.
- 원하는 때에 동작이 시작하도록 할 수 있죠.
- `setTimeout`은 스케줄링에 사용되는 가장 대표적인 함수입니다.
- 실무에서 맞닥뜨리는 비동기 동작은 아주 다양합니다.
- 스크립트나 모듈을 로딩하는 것 또한 비동기 동작입니다
- `src`에 있는 스크립트를 읽어오는 함수 `loadScript(src)`를 예시로 비동기 동작 처리가 어떻게 일어나는지 살펴봅시다.

```js
function loadScript(src) {
  // <script> 태그를 만들고 페이지에 태그를 추가합니다.
  // 태그가 페이지에 추가되면 src에 있는 스크립트를 로딩하고 실행합니다.
  let script = document.createElement("script");
  script.src = src;
  document.head.append(script);
}
```

- 함수 `loadScript(src)는 <script src="…">`를 동적으로 만들고 이를 문서에 추가합니다.
- 브라우저는 자동으로 태그에 있는 스크립트를 불러오고, 로딩이 완료되면 스크립트를 실행합니다.
- `loadScript(src)` 사용법은 다음과 같습니다.

```js
// 해당 경로에 위치한 스크립트를 불러오고 실행함
loadScript("/my/script.js");
```

- 그런데 이 때 스크립트는 `‘비동기적으로’` 실행됩니다.
- 로딩은 지금 당장 시작되더라도 실행은 함수가 끝난 후에야 되기 때문입니다.
- 따라서 `loadScript(…)` 아래에 있는 코드들은 스크립트 로딩이 종료되는 걸 기다리지 않습니다.

```js
loadScript("/my/script.js");
// loadScript 아래의 코드는
// 스크립트 로딩이 끝날 때까지 기다리지 않습니다.
// ...
```

- 스크립트 로딩이 끝나자마자 이 스크립트를 사용해 무언가를 해야만 한다고 가정해 봅시다.
- 스크립트 안에 다양한 함수가 정의되어 있고, 우리는 이 함수를 실행하길 원하는 상황입니다.
- 그런데 `loadScript(...)`를 호출하자마자 내부 함수를 호출하면 원하는 대로 작동하지 않습니다.

```js
loadScript("/my/script.js"); // script.js엔 "function newFunction() {…}"이 있습니다.

newFunction(); // 함수가 존재하지 않는다는 에러가 발생합니다!
```

- 에러는 브라우저가 스크립트를 읽어올 수 있는 시간을 충분히 확보하지 못했기 때문에 발생합니다.
- 그런데 현재로서는 함수 `loadScript`에서 스크립트 로딩이 완료되었는지 알 방법이 없네요.
- 언젠간 스크립트가 로드되고 실행도 되겠지만, 그게 다입니다.
- 원하는 대로 스크립트 안의 함수나 변수를 사용하려면 스크립트 로딩이 끝났는지 여부를 알 수 있어야 합니다.
- `loadScript`의 두 번째 인수로 스크립트 로딩이 끝난 후 실행될 함수인 콜백(callback) 함수를 추가해 봅시다(콜백 함수는 나중에 호출할 함수를 의미합니다.).

<br>

[출처]
https://ko.javascript.info/callbacks
